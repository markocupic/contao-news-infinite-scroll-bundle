"use strict";

/*
 * This file is part of Contao News Infinite Scroll Bundle.
 *
 * (c) Marko Cupic 2023 <m.cupic@gmx.ch>
 * @license LGPL-3.0+
 * For the full copyright and license information,
 * please view the LICENSE file that was distributed with this source code.
 * @link https://github.com/markocupic/contao-news-infinite-scroll-bundle
 */
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
const ContaoInfiniteScroll = {};
ContaoInfiniteScroll.Modes = {
    LOAD_MORE_BUTTON: 'load_more_button',
    AUTOLOAD_ON_DOMREADY: 'autoload_on_domready',
    INFINITE_SCROLL: 'infinite_scroll'
};
ContaoInfiniteScroll.Defaults = {
    // Loading mode
    loadingMode: ContaoInfiniteScroll.Modes.LOAD_MORE_BUTTON,
    // DOM element scroll area (default null, if you want to use the whole screen)
    scrollContainer: null,
    // Use document.querySelector("#myScrollArea") if you want to specify the scroll area
    // scrollContainer: document.querySelector("#myScrollArea"),

    // The urls are retrieved from the pagination. Specify the css selectors from the pagination inside the container.
    pagination: {
        selectorNext: '.pagination > .next > a.next[href]',
        selectorLast: '.pagination > .last > a.last[href]',
        paramPageRegex: 'page([_a-z]*)(\d*)'
    },
    // Load more button html markup
    loadMoreButtonMarkup: '<div class="inf-scr-load-more-btn-container"><button>load more</button></div>',
    // HTML: Show this message during the loading process
    loadingInProcessIndicatorMarkup: '<div class="inf-scr-loading-in-process-container">loading...</div>'
};

/**
 *
 * @type {{getUrlsFromPagination: ((function(*, null=, *): Promise<*>)|*)}}
 */
ContaoInfiniteScroll.Utils = {
    /**
     * Use this method to get the urls from the pagination items
     *
     * @param elNextLink
     * @param elLastLink
     * @param paginationUrlParamRegexPattern
     * @returns {Promise<unknown>}
     */
    getUrlsFromPagination: function (elNextLink, elLastLink = null, paginationUrlParamRegexPattern) {
        let arrUrls = [];

        // Get the first request url
        // Use el.getAttribute('href') because an empty href attribute will return true, when testing against el.hasAttribute('href'))
        const hrefNext = elNextLink.getAttribute('href') ? window.location.origin + '/' + elNextLink.getAttribute('href') : null;
        if (null === hrefNext) {
            console.warn('Infinite scroll initialization aborted! Could not find a valid pagination link.');
            return arrUrls;
        }

        // Retrieve the URL - and URLSearchParams objects from the first pagination url
        const urlNext = new URL(hrefNext);
        const urlParamsNext = urlNext.searchParams;
        let paramPage = null;
        for (const key of urlParamsNext.keys()) {
            let regexpParamPage = new RegExp(paginationUrlParamRegexPattern, "g");
            if (regexpParamPage.exec(key)) {
                paramPage = key;
                break;
            }
        }
        if (null === paramPage) {
            console.error('Infinite scroll initialization aborted! Could not find pagination link with pattern "' + paginationUrlParamRegexPattern + '".');
            return arrUrls;
        }
        const pageIdNext = parseInt(urlParamsNext.get(paramPage));
        let pageIdLast = pageIdNext;

        // If the next url is same to the last url there is no last url
        if (elLastLink) {
            // Get last request url
            // Use elLastLink.getAttribute('href') because an empty href attribute will return true, when testing against el.hasAttribute('href'))
            const hrefLast = elLastLink.getAttribute('href') ? window.location.origin + '/' + elLastLink.getAttribute('href') : null;
            if (null !== hrefLast) {
                // Retrieve the URL - and URLSearchParams objects from the last pagination url
                const urlLast = new URL(hrefLast);
                const urlParamsLast = urlLast.searchParams;
                if (urlParamsLast.has(paramPage)) {
                    pageIdLast = parseInt(urlParamsLast.get(paramPage));
                }
            }
        }

        // Generate all urls from first to last
        for (let i = pageIdNext; i <= pageIdLast; i++) {
            urlParamsNext.set(paramPage, i.toString());
            arrUrls.push(urlNext.origin + urlNext.pathname + '?' + urlParamsNext.toString());
        }
        return arrUrls;
    }
};
var _loadingMode = /*#__PURE__*/new WeakMap();
var _opts = /*#__PURE__*/new WeakMap();
var _container = /*#__PURE__*/new WeakMap();
var _scrollContainer = /*#__PURE__*/new WeakMap();
var _anchorPoint = /*#__PURE__*/new WeakMap();
var _executionStoppedAfterInitialization = /*#__PURE__*/new WeakMap();
var _blnLoadingInProcess = /*#__PURE__*/new WeakMap();
var _blnAllItemsLoaded = /*#__PURE__*/new WeakMap();
var _xhrInterval = /*#__PURE__*/new WeakMap();
var _listeners = /*#__PURE__*/new WeakMap();
var _initialize = /*#__PURE__*/new WeakMap();
var _dispatchEvent = /*#__PURE__*/new WeakMap();
var _hasListener = /*#__PURE__*/new WeakMap();
var _load = /*#__PURE__*/new WeakMap();
var _handleAjaxError = /*#__PURE__*/new WeakMap();
var _appendItemsToContainer = /*#__PURE__*/new WeakMap();
var _appendLoadMoreButtonAfterContainer = /*#__PURE__*/new WeakMap();
var _removeLoadMoreButton = /*#__PURE__*/new WeakMap();
var _appendLoadingIndicatorAfterContainer = /*#__PURE__*/new WeakMap();
var _removeLoadingIndicator = /*#__PURE__*/new WeakMap();
class ContaoInfiniteScrollApp {
    /**
     * @param listItemsContainer
     * @param options
     */
    constructor(_listItemsContainer, _options) {
        // Public fields
        _defineProperty(this, "arrUrls", []);
        _defineProperty(this, "blnHasError", false);
        _defineProperty(this, "blnErrorMessage", '');
        _defineProperty(this, "urlIndex", 0);
        // Private fields
        _classPrivateFieldInitSpec(this, _loadingMode, {
            writable: true,
            value: null
        });
        _classPrivateFieldInitSpec(this, _opts, {
            writable: true,
            value: {}
        });
        _classPrivateFieldInitSpec(this, _container, {
            writable: true,
            value: null
        });
        _classPrivateFieldInitSpec(this, _scrollContainer, {
            writable: true,
            value: null
        });
        _classPrivateFieldInitSpec(this, _anchorPoint, {
            writable: true,
            value: null
        });
        _classPrivateFieldInitSpec(this, _executionStoppedAfterInitialization, {
            writable: true,
            value: false
        });
        _classPrivateFieldInitSpec(this, _blnLoadingInProcess, {
            writable: true,
            value: false
        });
        _classPrivateFieldInitSpec(this, _blnAllItemsLoaded, {
            writable: true,
            value: false
        });
        _classPrivateFieldInitSpec(this, _xhrInterval, {
            writable: true,
            value: null
        });
        _classPrivateFieldInitSpec(this, _listeners, {
            writable: true,
            value: {
                'contao.infinite_scroll.initialize': [],
                'contao.infinite_scroll.xhr_start': [],
                'contao.infinite_scroll.xhr_complete': [],
                'contao.infinite_scroll.xhr_error': [],
                'contao.infinite_scroll.append': [],
                'contao.infinite_scroll.appended': []
            }
        });
        /**
         *
         */
        _defineProperty(this, "execute", function () {
            // Dispatch 'contao.infinite_scroll.initialize' event
            if (_classPrivateFieldGet(this, _hasListener).call(this, 'contao.infinite_scroll.initialize')) {
                if (false === _classPrivateFieldGet(this, _dispatchEvent).call(this, 'contao.infinite_scroll.initialize', [this])) {
                    _classPrivateFieldSet(this, _executionStoppedAfterInitialization, true);
                    return;
                }
            }

            // If there are no urls, there is nothing to load
            if (this.arrUrls.length === 0) {
                return;
            }

            // Handle various loading modes
            if (_classPrivateFieldGet(this, _loadingMode) === ContaoInfiniteScroll.Modes.AUTOLOAD_ON_DOMREADY) {
                _classPrivateFieldGet(this, _load).call(this);
                _classPrivateFieldSet(this, _xhrInterval, setInterval(() => {
                    _classPrivateFieldGet(this, _load).call(this);
                }, 3000));
            } else if (_classPrivateFieldGet(this, _loadingMode) === ContaoInfiniteScroll.Modes.LOAD_MORE_BUTTON) {
                _classPrivateFieldGet(this, _appendLoadMoreButtonAfterContainer).call(this);
            } else if (_classPrivateFieldGet(this, _loadingMode) === ContaoInfiniteScroll.Modes.INFINITE_SCROLL) {
                const options = {
                    // Set root to null to use the whole screen as scroll area
                    root: _classPrivateFieldGet(this, _scrollContainer),
                    // Do not grow or shrink the root area
                    rootMargin: "0px",
                    // Threshold of 1.0 will fire callback when 100% of element is visible
                    threshold: 1.0
                };
                const observer = new IntersectionObserver(entries => {
                    // Callback to be fired
                    // Entries is a list of elements out of our targets that reported a change.
                    entries.forEach(entry => {
                        // Only add to list if element is coming into view not leaving
                        if (entry.isIntersecting) {
                            _classPrivateFieldGet(this, _load).call(this);
                        }
                    });
                }, options);
                observer.observe(_classPrivateFieldGet(this, _anchorPoint));
            } else {
                throw new Error(_classPrivateFieldGet(this, _loadingMode) + ' is not a valid loading mode. Please choose one of these: "' + Object.values(ContaoInfiniteScroll.Modes).join('", ') + '".');
            }
        });
        /**
         * Register listeners
         *
         * @param eventName
         * @param callback
         * @returns {ContaoInfiniteScrollApp.on}
         */
        _defineProperty(this, "on", function (eventName, callback) {
            if (!_classPrivateFieldGet(this, _listeners).hasOwnProperty(eventName)) {
                throw new Error(eventName + ' is not a valid event name. Please choose one of these: "' + Object.keys(_classPrivateFieldGet(this, _listeners)).join('", ') + '".');
            }
            _classPrivateFieldGet(this, _listeners)[eventName].push(callback);
            return this;
        });
        /**
         * @param option
         * @returns {*|boolean}
         */
        _defineProperty(this, "getOption", function (option) {
            if (typeof _classPrivateFieldGet(this, _opts)[option] !== 'undefined') {
                return _classPrivateFieldGet(this, _opts)[option];
            }
            return false;
        });
        /**
         * @returns {*}
         */
        _defineProperty(this, "getContainer", function () {
            return _classPrivateFieldGet(this, _container);
        });
        /**
         * @param listItemsContainer
         * @param options
         * @returns {ContaoInfiniteScrollApp.initialize}
         */
        _classPrivateFieldInitSpec(this, _initialize, {
            writable: true,
            value: function (listItemsContainer, options) {
                _classPrivateFieldSet(this, _container, listItemsContainer);
                _classPrivateFieldSet(this, _opts, {
                    ...ContaoInfiniteScroll.Defaults,
                    ...(options !== null && options !== void 0 ? options : {})
                });

                // Set the loading mode
                _classPrivateFieldSet(this, _loadingMode, _classPrivateFieldGet(this, _opts)['loadingMode']);
                if (!Object.values(ContaoInfiniteScroll.Modes).includes(_classPrivateFieldGet(this, _loadingMode))) {
                    throw new Error(_classPrivateFieldGet(this, _loadingMode) + ' is not a valid loading mode. Please choose one of these: "' + Object.values(ContaoInfiniteScroll.Modes).join('", ') + '".');
                }

                // Retrieve urls from pagination
                this.arrUrls = ContaoInfiniteScroll.Utils.getUrlsFromPagination(_classPrivateFieldGet(this, _container).querySelector(_classPrivateFieldGet(this, _opts)['pagination']['selectorNext']), _classPrivateFieldGet(this, _container).querySelector(_classPrivateFieldGet(this, _opts)['pagination']['selectorLast']), _classPrivateFieldGet(this, _opts)['pagination']['paramPageRegex']);

                // Set the anchor point
                _classPrivateFieldSet(this, _anchorPoint, _classPrivateFieldGet(this, _container).parentElement.querySelector('.infinite_scroll_anchor'));
                return this;
            }
        });
        /**
         *
         * @param strEventName
         * @param args
         * @returns {*}
         */
        _classPrivateFieldInitSpec(this, _dispatchEvent, {
            writable: true,
            value: function (strEventName, args = []) {
                let returnValue;
                for (let index = 0; index < _classPrivateFieldGet(this, _listeners)[strEventName].length; index++) {
                    returnValue = _classPrivateFieldGet(this, _listeners)[strEventName][index](...args);
                }
                return returnValue;
            }
        });
        /**
         * @param strEventName
         * @returns {boolean}
         */
        _classPrivateFieldInitSpec(this, _hasListener, {
            writable: true,
            value: function (strEventName) {
                return _classPrivateFieldGet(this, _listeners)[strEventName].length > 0;
            }
        });
        /**
         * Load items from server
         */
        _classPrivateFieldInitSpec(this, _load, {
            writable: true,
            value: function () {
                if (_classPrivateFieldGet(this, _blnLoadingInProcess) === true || _classPrivateFieldGet(this, _blnAllItemsLoaded) === true) {
                    return;
                }
                this.blnHasError = false;
                let currentUrl = this.arrUrls[this.urlIndex];
                if (typeof currentUrl !== 'undefined') {
                    currentUrl = currentUrl + '&ajaxCall=true';

                    // Set aria-busy property to true
                    _classPrivateFieldGet(this, _container).setAttribute('aria-busy', 'true');
                    _classPrivateFieldSet(this, _blnLoadingInProcess, true);
                    _classPrivateFieldGet(this, _removeLoadMoreButton).call(this);
                    _classPrivateFieldGet(this, _appendLoadingIndicatorAfterContainer).call(this);

                    // Dispatch 'contao.infinite_scroll.xhr_start' event
                    if (_classPrivateFieldGet(this, _hasListener).call(this, 'contao.infinite_scroll.xhr_start')) {
                        _classPrivateFieldGet(this, _dispatchEvent).call(this, 'contao.infinite_scroll.xhr_start', [this, currentUrl]);
                    }
                    fetch(currentUrl, {
                        method: "GET",
                        headers: {
                            'x-requested-with': 'XMLHttpRequest'
                        }
                    }).then(response => {
                        if (response.ok) {
                            return response.json();
                        }
                        return Promise.reject(response);
                    }).then(json => {
                        if (json['data'] === 'undefined') {
                            return Promise.reject(json);
                        }
                        return json['data'];
                    }).then(responseText => {
                        this.blnHasError = false;
                        if (typeof responseText === 'string') {
                            // Dispatch 'contao.infinite_scroll.xhr_complete' event
                            if (_classPrivateFieldGet(this, _hasListener).call(this, 'contao.infinite_scroll.xhr_complete')) {
                                responseText = _classPrivateFieldGet(this, _dispatchEvent).call(this, 'contao.infinite_scroll.xhr_complete', [this, responseText]);
                            }
                        } else {
                            return Promise.reject('Response data is not of type string.');
                        }
                        if (this.blnHasError === false) {
                            this.urlIndex++;
                            setTimeout(() => {
                                // Append the loaded content to the DOM
                                _classPrivateFieldGet(this, _appendItemsToContainer).call(this, responseText);
                            }, 1000);
                        } else {
                            return Promise.reject(response);
                        }
                    }).catch(function (error) {
                        console.warn(error);
                        _classPrivateFieldGet(this, _handleAjaxError).call(this, error);
                    }).finally(() => {
                        setTimeout(() => {
                            // Set aria-busy property to false
                            _classPrivateFieldGet(this, _container).setAttribute('aria-busy', 'false');

                            // Remove the "loading in progress indicator"
                            _classPrivateFieldGet(this, _removeLoadingIndicator).call(this);

                            // If all items are loaded:
                            if (this.arrUrls.length === this.urlIndex) {
                                _classPrivateFieldSet(this, _blnAllItemsLoaded, true);

                                // Remove the "load more button"
                                _classPrivateFieldGet(this, _removeLoadMoreButton).call(this);

                                // Clear the autoloader interval
                                if (typeof _classPrivateFieldGet(this, _xhrInterval) !== 'undefined') {
                                    clearInterval(_classPrivateFieldGet(this, _xhrInterval));
                                }
                            } else {
                                // Again append the load more button to the DOM
                                if (_classPrivateFieldGet(this, _loadingMode) === ContaoInfiniteScroll.Modes.LOAD_MORE_BUTTON) {
                                    _classPrivateFieldGet(this, _appendLoadMoreButtonAfterContainer).call(this);
                                }
                            }
                            _classPrivateFieldSet(this, _blnLoadingInProcess, false);
                        }, 1000);
                    });
                } else {
                    _classPrivateFieldSet(this, _blnAllItemsLoaded, true);
                    if (typeof _classPrivateFieldGet(this, _xhrInterval) !== 'undefined') {
                        clearInterval(_classPrivateFieldGet(this, _xhrInterval));
                    }
                }
            }
        });
        /**
         * @param errorMsg
         */
        _classPrivateFieldInitSpec(this, _handleAjaxError, {
            writable: true,
            value: function (errorMsg = '') {
                this.blnHasError = true;
                _classPrivateFieldSet(this, _blnLoadingInProcess, false);

                // Dispatch 'contao.infinite_scroll.xhr_error' event
                if (_classPrivateFieldGet(this, _hasListener).call(this, 'contao.infinite_scroll.xhr_error')) {
                    _classPrivateFieldGet(this, _dispatchEvent).call(this, 'contao.infinite_scroll.xhr_error', [this, errorMsg]);
                }
            }
        });
        /**
         * Append loaded markup to the container
         */
        _classPrivateFieldInitSpec(this, _appendItemsToContainer, {
            writable: true,
            value: function (responseText) {
                // Create document fragment from response
                const template = document.createElement("template");
                template.innerHTML = responseText;
                let documentFragment = template.content;

                // Dispatch 'contao.infinite_scroll.append' event
                if (_classPrivateFieldGet(this, _hasListener).call(this, 'contao.infinite_scroll.append')) {
                    documentFragment = _classPrivateFieldGet(this, _dispatchEvent).call(this, 'contao.infinite_scroll.append', [this, documentFragment]);
                }

                // Append document fragment to DOM
                _classPrivateFieldGet(this, _container).append(documentFragment);

                // Dispatch 'contao.infinite_scroll.appended' event
                if (_classPrivateFieldGet(this, _hasListener).call(this, 'contao.infinite_scroll.appended')) {
                    _classPrivateFieldGet(this, _dispatchEvent).call(this, 'contao.infinite_scroll.appended', [this]);
                }
            }
        });
        _classPrivateFieldInitSpec(this, _appendLoadMoreButtonAfterContainer, {
            writable: true,
            value: function () {
                let loadMoreBtn = _classPrivateFieldGet(this, _container).querySelector('.inf-scr-load-more-btn-container');
                if (!loadMoreBtn) {
                    // Append the load more button
                    const loadMoreBtnTemplate = document.createElement("template");
                    loadMoreBtnTemplate.innerHTML = _classPrivateFieldGet(this, _opts).loadMoreButtonMarkup;
                    loadMoreBtn = loadMoreBtnTemplate.content.firstElementChild;
                    _classPrivateFieldGet(this, _container).after(loadMoreBtn);
                    loadMoreBtn.classList.add('inf-scr-load-more-btn-container');
                    loadMoreBtn.setAttribute('data-display', loadMoreBtn.style.display !== '' ? loadMoreBtn.style.display : 'block');

                    // Hide the button during the loading process
                    loadMoreBtn.addEventListener('click', e => {
                        loadMoreBtn.style.display = 'none';
                        _classPrivateFieldGet(this, _load).call(this);
                    });
                }
            }
        });
        _classPrivateFieldInitSpec(this, _removeLoadMoreButton, {
            writable: true,
            value: function () {
                const button = _classPrivateFieldGet(this, _container).parentNode.querySelector('.inf-scr-load-more-btn-container');
                if (button) {
                    button.remove();
                }
            }
        });
        _classPrivateFieldInitSpec(this, _appendLoadingIndicatorAfterContainer, {
            writable: true,
            value: function () {
                let elLoadingIndicator = _classPrivateFieldGet(this, _container).querySelector('.inf-scr-loading-in-process-indicator');
                if (!elLoadingIndicator && _classPrivateFieldGet(this, _opts).loadingInProcessIndicatorMarkup !== '') {
                    // Append the loading indicator after the container
                    const indicatorTemplate = document.createElement("template");
                    indicatorTemplate.innerHTML = _classPrivateFieldGet(this, _opts).loadingInProcessIndicatorMarkup;
                    elLoadingIndicator = indicatorTemplate.content.firstElementChild;
                    _classPrivateFieldGet(this, _container).after(elLoadingIndicator);
                    elLoadingIndicator.classList.add('inf-scr-loading-in-process-indicator');
                }
            }
        });
        _classPrivateFieldInitSpec(this, _removeLoadingIndicator, {
            writable: true,
            value: function () {
                const indicators = _classPrivateFieldGet(this, _container).parentElement.querySelectorAll('.inf-scr-loading-in-process-indicator');
                indicators.forEach(el => {
                    el.remove();
                });
            }
        });
        _classPrivateFieldGet(this, _initialize).call(this, _listItemsContainer, _options);
    }
}